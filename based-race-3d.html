<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>Based Race 3D</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      background: #0a0a0f;
      overflow: hidden;
      font-family: 'Segoe UI', sans-serif;
    }
    #game-container {
      position: relative;
      width: 100vw;
      height: 100vh;
    }
    canvas { display: block; }
    #ui {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      padding: 15px 20px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      pointer-events: none;
      z-index: 100;
    }
    #timer {
      font-size: 28px;
      font-weight: bold;
      color: #00ffcc;
      text-shadow: 0 0 10px #00ffcc, 2px 2px 4px #000;
    }
    #status {
      font-size: 24px;
      font-weight: bold;
      color: #ffd700;
      text-shadow: 0 0 15px #ffd700, 2px 2px 4px #000;
    }
    #start-screen, #game-over {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      background: linear-gradient(180deg, #0a0a0f 0%, #1a1a2e 50%, #0a0a0f 100%);
      z-index: 200;
    }
    #start-screen h1 {
      font-size: 48px;
      color: #e94560;
      text-shadow: 0 0 30px #e94560, 4px 4px 0 #000;
      margin-bottom: 10px;
      letter-spacing: 4px;
    }
    #start-screen h2 {
      font-size: 24px;
      color: #00ffcc;
      text-shadow: 0 0 20px #00ffcc;
      margin-bottom: 40px;
    }
    .btn {
      padding: 18px 60px;
      font-size: 22px;
      font-weight: bold;
      background: linear-gradient(180deg, #e94560 0%, #b8354a 100%);
      color: #fff;
      border: none;
      border-radius: 50px;
      cursor: pointer;
      text-transform: uppercase;
      box-shadow: 0 6px 0 #8a2535, 0 0 30px rgba(233,69,96,0.5);
    }
    .btn:hover { transform: translateY(-2px); }
    #final-score {
      font-size: 72px;
      color: #ffd700;
      text-shadow: 0 0 30px #ffd700;
      margin: 20px 0;
    }
    #debug-ui {
      position: absolute;
      top: 70px;
      right: 10px;
      color: #00ff00;
      font-size: 14px;
      font-family: monospace;
      text-shadow: 1px 1px 2px #000;
      z-index: 100;
    }
    .hidden { display: none !important; }
    #controls {
      position: absolute;
      bottom: 30px;
      left: 0;
      right: 0;
      display: flex;
      justify-content: space-around;
      z-index: 150;
    }
    .control-btn {
      width: 100px;
      height: 100px;
      background: rgba(255,255,255,0.15);
      border: 3px solid rgba(255,255,255,0.4);
      border-radius: 50%;
      display: flex;
      justify-content: center;
      align-items: center;
      font-size: 40px;
      color: rgba(255,255,255,0.8);
      user-select: none;
    }
    .control-btn:active {
      background: rgba(233,69,96,0.6);
      border-color: #e94560;
    }
    #loading {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      color: #00ffcc;
      font-size: 24px;
      z-index: 300;
    }
  </style>
</head>
<body>
  <div id="game-container">
    <div id="loading">LOADING ASSETS...</div>
    
    <div id="ui">
      <div id="timer">00:00.00</div>
      <div id="status">üèÅ BASED RACE 3D üèÅ</div>
    </div>
    
    <div id="debug-ui"></div>
    
    <div id="start-screen" class="hidden">
      <h1>BASED RACE</h1>
      <h2>3D EDITION</h2>
      <p style="color:#888;margin-bottom:30px;font-size:14px;">Tap LEFT/RIGHT or use Arrow Keys</p>
      <button class="btn" id="startBtn">START RACE</button>
    </div>
    
    <div id="game-over" class="hidden">
      <h1 style="font-size:36px;color:#e94560;margin-bottom:10px;">RACE FINISH!</h1>
      <p style="color:#888;">Winner</p>
      <div id="winner-name" style="font-size:48px;color:#ffd700;margin:10px 0;">JESSE</div>
      <p style="color:#888;margin-top:20px;">Final Time</p>
      <div id="final-score">00:00.00</div>
      <button class="btn" id="restartBtn">RACE AGAIN</button>
    </div>
    
    <div id="controls">
      <div class="control-btn" id="leftBtn">‚óÄ</div>
      <div class="control-btn" id="rightBtn">‚ñ∂</div>
    </div>
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  
  <script>
    // Asset URLs from GitHub
    const ASSETS = {
      jesse: 'https://raw.githubusercontent.com/BasedRace/BasedRace/master/assets/jesse.png',
      barmstrong: 'https://raw.githubusercontent.com/BasedRace/BasedRace/master/assets/barmstrong.png',
      deployer: 'https://raw.githubusercontent.com/BasedRace/BasedRace/master/assets/deployer.png',
      dish: 'https://raw.githubusercontent.com/BasedRace/BasedRace/master/assets/dish.png',
      env1: 'https://raw.githubusercontent.com/BasedRace/BasedRace/master/assets/env1.png',
      env2: 'https://raw.githubusercontent.com/BasedRace/BasedRace/master/assets/env2.png',
      start: 'https://raw.githubusercontent.com/BasedRace/BasedRace/master/assets/start.png',
      finish: 'https://raw.githubusercontent.com/BasedRace/BasedRace/master/assets/finish.png'
    };
    
    // Load texture
    function loadTexture(url) {
      return new Promise(resolve => {
        new THREE.TextureLoader().load(url, resolve);
      });
    }
    
    // Load all assets
    async function loadAssets() {
      const loader = new THREE.TextureLoader();
      const textures = {};
      
      for (const [name, url] of Object.entries(ASSETS)) {
        textures[name] = await new Promise(resolve => {
          loader.load(url, tex => {
            tex.magFilter = THREE.NearestFilter;
            tex.minFilter = THREE.NearestFilter;
            resolve(tex);
          });
        });
      }
      
      document.getElementById('loading').classList.add('hidden');
      document.getElementById('start-screen').classList.remove('hidden');
      
      return textures;
    }
    
    // Elements
    const timerEl = document.getElementById('timer');
    const statusEl = document.getElementById('status');
    const startScreen = document.getElementById('start-screen');
    const gameOverScreen = document.getElementById('game-over');
    const winnerNameEl = document.getElementById('winner-name');
    const finalScoreEl = document.getElementById('final-score');
    const startBtn = document.getElementById('startBtn');
    const restartBtn = document.getElementById('restartBtn');
    const leftBtn = document.getElementById('leftBtn');
    const rightBtn = document.getElementById('rightBtn');
    const debugUi = document.getElementById('debug-ui');
    
    // Three.js setup
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x0a0a0f);
    scene.fog = new THREE.Fog(0x0a0a0f, 30, 150);
    
    const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(0, 6, 12);
    camera.lookAt(0, 0, 0);
    
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    document.getElementById('game-container').insertBefore(renderer.domElement, document.getElementById('ui'));
    
    // Lights
    scene.add(new THREE.AmbientLight(0x404040, 1));
    const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
    dirLight.position.set(5, 10, 5);
    scene.add(dirLight);
    
    // Game state
    let gameRunning = false;
    let raceTime = 0;
    let trackSpeed = 0;
    const baseTrackSpeed = 0.3;
    let textures = {};
    
    // Road segments
    const roadSegments = [];
    const segmentLength = 15;
    const numSegments = 40;
    
    // Create road with textures
    function createRoad() {
      // Ground
      const ground = new THREE.Mesh(
        new THREE.PlaneGeometry(80, 200),
        new THREE.MeshStandardMaterial({ color: 0x1a1a1a })
      );
      ground.rotation.x = -Math.PI / 2;
      ground.position.y = -0.1;
      ground.position.z = -50;
      scene.add(ground);
      
      // Road with textures
      for (let i = 0; i < numSegments; i++) {
        const segment = new THREE.Group();
        segment.position.z = -i * segmentLength;
        
        // Road surface - use env texture
        const tex = textures.env1 || textures.env2;
        const roadMat = tex ? 
          new THREE.MeshStandardMaterial({ map: tex, side: THREE.DoubleSide }) :
          new THREE.MeshStandardMaterial({ color: 0x2d2d2d });
        
        const road = new THREE.Mesh(new THREE.PlaneGeometry(10, segmentLength), roadMat);
        road.rotation.x = -Math.PI / 2;
        segment.add(road);
        
        // Lane lines
        const lineMat = new THREE.MeshBasicMaterial({ color: 0xffd700 });
        
        // Dashed center lines
        for (let d = 0; d < 3; d++) {
          const dash = new THREE.Mesh(
            new THREE.PlaneGeometry(0.1, 2),
            lineMat
          );
          dash.rotation.x = -Math.PI / 2;
          dash.position.set(0, 0.01, -segmentLength/2 + d * 5 + 2.5);
          segment.add(dash);
        }
        
        // Edge lines
        const edgeMat = new THREE.MeshBasicMaterial({ color: i % 2 === 0 ? 0xe94560 : 0xffffff });
        [-5, 5].forEach(x => {
          const edge = new THREE.Mesh(new THREE.PlaneGeometry(0.2, segmentLength), edgeMat);
          edge.rotation.x = -Math.PI / 2;
          edge.position.set(x, 0.01, 0);
          segment.add(edge);
        });
        
        // Start/finish line
        if (i === 2) {
          const startMat = new THREE.MeshBasicMaterial({ 
            map: textures.start,
            transparent: true,
            opacity: 0.9
          });
          const startLine = new THREE.Mesh(new THREE.PlaneGeometry(10, 2), startMat);
          startLine.rotation.x = -Math.PI / 2;
          startLine.position.set(0, 0.02, 0);
          segment.add(startLine);
        }
        
        if (i === numSegments - 5) {
          const finishMat = new THREE.MeshBasicMaterial({ 
            map: textures.finish,
            transparent: true,
            opacity: 0.9
          });
          const finishLine = new THREE.Mesh(new THREE.PlaneGeometry(10, 2), finishMat);
          finishLine.rotation.x = -Math.PI / 2;
          finishLine.position.set(0, 0.02, 0);
          segment.add(finishLine);
        }
        
        scene.add(segment);
        roadSegments.push(segment);
      }
    }
    
    // Karts with character textures
    const racers = [];
    const racerData = [
      { name: 'Jesse', color: 0x00bcd4, tex: 'jesse' },
      { name: 'Barmstrong', color: 0x9c27b0, tex: 'barmstrong' },
      { name: 'Deployer', color: 0xff9800, tex: 'deployer' },
      { name: 'Dish', color: 0xe94560, tex: 'dish' }
    ];
    
    function createKart(data, lane) {
      const kart = new THREE.Group();
      
      // Use character texture on a plane (billboard style)
      const tex = textures[data.tex];
      if (tex) {
        const spriteMat = new THREE.MeshBasicMaterial({ 
          map: tex, 
          transparent: true,
          side: THREE.DoubleSide
        });
        
        // Character sprite
        const sprite = new THREE.Mesh(
          new THREE.PlaneGeometry(1.5, 2),
          spriteMat
        );
        sprite.position.y = 1.2;
        kart.add(sprite);
      } else {
        // Fallback - colored box
        const body = new THREE.Mesh(
          new THREE.BoxGeometry(1, 1, 1.5),
          new THREE.MeshStandardMaterial({ color: data.color })
        );
        body.position.y = 0.5;
        kart.add(body);
      }
      
      // Position in lane
      const laneX = (lane - 1.5) * 2.2;
      kart.position.set(laneX, 0, 0);
      
      kart.userData = {
        name: data.name,
        lane,
        targetX: laneX,
        x: laneX,
        baseSpeed: 0.06 + Math.random() * 0.03,
        speed: 0,
        progress: 0,
        finished: false
      };
      
      scene.add(kart);
      racers.push(kart);
      return kart;
    }
    
    // Initialize
    function init() {
      roadSegments.forEach(seg => scene.remove(seg));
      roadSegments.length = 0;
      racers.forEach(r => scene.remove(r));
      racers.length = 0;
      
      createRoad();
      racerData.forEach((data, i) => createKart(data, i));
      
      camera.position.set(0, 6, 12);
      raceTime = 0;
      trackSpeed = 0;
    }
    
    // Move player
    function movePlayer(dir) {
      if (!gameRunning) return;
      const player = racers[0];
      const data = player.userData;
      if (dir === 'left' && data.lane > 0) data.lane--;
      if (dir === 'right' && data.lane < 3) data.lane++;
      data.targetX = (data.lane - 1.5) * 2.2;
    }
    
    // Timer
    function updateTimer() {
      const mins = Math.floor(raceTime / 60);
      const secs = Math.floor(raceTime % 60);
      const ms = Math.floor((raceTime % 1) * 100);
      timerEl.textContent = String(mins).padStart(2,'0') + ':' + String(secs).padStart(2,'0') + '.' + String(ms).padStart(2,'0');
    }
    
    // Game loop
    let lastTime = 0;
    function animate(currentTime) {
      requestAnimationFrame(animate);
      const delta = (currentTime - lastTime) / 1000;
      lastTime = currentTime;
      
      if (!gameRunning || delta > 0.1) {
        renderer.render(scene, camera);
        return;
      }
      
      raceTime += delta;
      updateTimer();
      
      if (trackSpeed < baseTrackSpeed * 2.5) trackSpeed += delta * 0.08;
      
      // Move road
      roadSegments.forEach(seg => {
        seg.position.z += trackSpeed * 30;
        if (seg.position.z > 20) seg.position.z -= numSegments * segmentLength;
      });
      
      // Update racers
      let firstFinisher = null;
      racers.forEach((kart, index) => {
        const data = kart.userData;
        
        // AI speed variation
        const bonus = Math.sin(currentTime * 0.003 + index) * 0.015;
        const targetSpeed = data.baseSpeed + bonus;
        data.speed += (targetSpeed - data.speed) * 0.05;
        data.progress += data.speed;
        
        // Move forward
        kart.position.z = -data.progress * 15;
        
        // Lane switch
        data.x += (data.targetX - data.x) * 0.12;
        kart.position.x = data.x;
        
        // Bobbing
        kart.position.y = Math.sin(currentTime * 0.012 + index) * 0.08;
        
        // Lean
        kart.rotation.z = -(data.targetX - data.x) * 0.4;
        
        // Face the right direction (billboard)
        kart.children.forEach(child => {
          if (child.isMesh && child.geometry.type === 'PlaneGeometry') {
            child.lookAt(camera.position.x, child.position.y + kart.position.y, camera.position.z);
          }
        });
        
        // Check finish (around z = -350)
        if (!data.finished && kart.position.z < -350) {
          data.finished = true;
          if (!firstFinisher) firstFinisher = data;
        }
      });
      
      // Camera follow player
      const playerKart = racers[0];
      camera.position.z = playerKart.position.z + 12;
      camera.position.x = playerKart.position.x * 0.4;
      
      if (firstFinisher) endGame(firstFinisher);
      
      // Debug
      debugUi.innerHTML = racers.map(r => 
        r.userData.name + ': ' + Math.abs(r.position.z).toFixed(1) + 'm'
      ).join('<br>');
      
      renderer.render(scene, camera);
    }
    
    function endGame(winner) {
      gameRunning = false;
      winnerNameEl.textContent = winner.name.toUpperCase();
      finalScoreEl.textContent = timerEl.textContent;
      statusEl.textContent = 'üèÜ ' + winner.name + ' WINS! üèÜ';
      gameOverScreen.classList.remove('hidden');
    }
    
    function startGame() {
      startScreen.classList.add('hidden');
      gameOverScreen.classList.add('hidden');
      gameRunning = true;
      init();
      raceTime = 0;
      trackSpeed = baseTrackSpeed;
    }
    
    // Events
    startBtn.onclick = startGame;
    restartBtn.onclick = startGame;
    document.onkeydown = e => {
      if (e.key === 'ArrowLeft' || e.key === 'a') movePlayer('left');
      if (e.key === 'ArrowRight' || e.key === 'd') movePlayer('right');
    };
    leftBtn.ontouchstart = e => { e.preventDefault(); movePlayer('left'); };
    leftBtn.onmousedown = e => { e.preventDefault(); movePlayer('left'); };
    rightBtn.ontouchstart = e => { e.preventDefault(); movePlayer('right'); };
    rightBtn.onmousedown = e => { e.preventDefault(); movePlayer('right'); };
    window.onresize = () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    };
    
    // Start
    loadAssets().then(tex => {
      textures = tex;
      init();
      animate(0);
    });
  </script>
</body>
</html>
